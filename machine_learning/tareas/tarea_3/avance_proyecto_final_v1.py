# -*- coding: utf-8 -*-
"""Avance_proyecto_final v1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_nEuK4zjxbgon4k0U6qA4V_zBE3eNxdS

# De los datos del IMSS:

- Adecuar los "headers" para que sean cortos y significativos. ✅
- Rellenar datos en caso de ser necesario. ✅
- Mostrar graficas con las matrices de correlación, gráficas de barras y transformaciones tipo logarítmicas (sólo sí es necesario) ✅
- Generar una tabla con estadística descriptiva. ✅
- Estandarizar los datos ✅
- Analizar, si es posible generar nuevas columnas con "ratios de variables" ✅
- Hacer el proceso con Pipelines
- Predecir el número de pacientes que llegan a hospitalización a partir de admisión y terapia intensiva mediante regresión lineal.


>Entregar un pequeño reporte con los pasos realizados y las gráficas y tablas obtenidas. Agregar su código. Todo se agrega en un archivo .zip

# Paso I / VIII
Cargar los datos desde google drive
"""

# Install google-colab package
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import numpy as np

try:
    from google.colab import drive  # type: ignore
    drive.mount('/content/drive')
    file_path = '/content/drive/My Drive/Colab Notebooks/data/datos_reorganizados.csv'  # Ajusta la ruta
except ImportError:
    file_path = 'datos_reorganizados.csv'

df = pd.read_csv(file_path)

# Mostrar las primeras filas
df.head()

"""# Paso II / VIII
Vamos a adecuar los headers:
```python

'''
Header 0 : año -> anio
Header 1 : mes -> mes
Header 2 : Numero de pacientes que ingresan a Admision Hospitalaria -> numero_pacientes_admision_hospitalaria
Header 3 : Numero de personas con ingreso de admision contínua a Hospital -> numero_pacientes_admision_continua
Header 4 : Numero de personas con ingreso de admision urgencias a terapia -> numero_pacientes_admision_urgencias
Header 5 : Numero de pacientes en alta de admision -> numero_pacientes_alta_admision
Header 6 : Defunciones en Terapias -> defunciones_terapia
Header 7 : Pacientes de terapia a Hospital -> pacientes_terapia_hospital
Header 8 : Defunciones en Urgencias -> defunciones_urgencias
Header 9 : Egresos Hospitalarios -> egresos_hospitalarios
Header 10 : Defunciones Hospitalarias -> defunciones_hospitalarias
Header 11 : Intervenciones quirúrgicas -> intervenciones_quirogicas
Header 12 : uso de tiempo quirurgico fin de semana en horas -> uso_tiempo_quirogico_fin_semana_horas
header 13: uso de tiempo quirurgico dias habiles en horas -> uso_tiempo_quirogico_dias_habiles_horas
'''
```

"""

# renombrar las columnas
df.rename(columns={
    'año': 'anio',
    'mes': 'mes',
    'Numero de pacientes que ingresan a Admision Hospitalaria': 'numero_pacientes_admision_hospitalaria',
    'Numero de personas con ingreso de admision contínua a Hospital': 'numero_pacientes_admision_continua',
    'Numero de personas con ingreso de admision urgencias  a terapia': 'numero_pacientes_admision_urgencias',
    'Numero de pacientes en alta  de admision ': 'numero_pacientes_alta_admision',
    'Defunciones en Terapias': 'defunciones_terapia',
    'Pacientes de terapia a Hospital': 'pacientes_terapia_hospital',
    'Defunciones en Urgencias ': 'defunciones_urgencias',
    'Egresos Hospitalarios': 'egresos_hospitalarios',
    'Defunciones Hospitalarias': 'defunciones_hospitalarias',
    'Intervenciones quirúrgicas': 'intervenciones_quirogicas',
    'uso de tiempo quirurgico fin de semana en horas': 'uso_tiempo_quirogico_fin_semana_horas',
    'uso de tiempo quirurgico dias habiles en horas': 'uso_tiempo_quirogico_dias_habiles_horas'
}, inplace=True)
# Mostrar las primeras filas
df.head(10)

"""# Paso III / VIII
Generar gráficas de barras y matrices de correlación
"""

# Matriz de correlación
plt.figure(figsize=(10, 8))
corr = df.select_dtypes(include=[np.number]).corr()
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title('Matriz de Correlación')
plt.savefig('matriz_correlacion.pdf')

# Grafica de barras
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Crear una figura grande para contener todos los gráficos
fig, axes = plt.subplots(7, 2, figsize=(20, 30))
axes = axes.flatten()

# Gráfica de barras para cada columna numérica, comenzando desde la segunda columna
for i, col in enumerate(df.select_dtypes(include=[np.number]).columns[1:]):
    sns.barplot(x='mes', y=col, hue='anio', data=df, ax=axes[i])
    axes[i].set_title(col)
    axes[i].set_xlabel('Mes')
    axes[i].set_ylabel(col)
    axes[i].legend(title='Año')

#fig.delaxes(axes[-1])
plt.tight_layout()
plt.savefig('graficas_barras.pdf')
plt.show()

"""# Paso IV / VIII
Generar una tabla con estadística descriptiva
"""

df.describe()

"""# Paso V /VIII
Estandarizar los datos
"""

from sklearn.preprocessing import StandardScaler

# Seleccionar solo las columnas numéricas
numeric_columns = df.select_dtypes(include=[np.number]).columns

# Crear un objeto StandardScaler
scaler = StandardScaler()

# Ajustar y transformar los datos
df[numeric_columns] = scaler.fit_transform(df[numeric_columns])

# Verificar los datos estandarizados
print(df.head())

"""# Paso VI / VIII
Generar nuevas columnas con "ratios de variables"


# Paso VII / VIII
Generar un pipeline para el preprocesamiento de los datos
"""

from sklearn.pipeline import make_pipeline
from sklearn.compose import ColumnTransformer, make_column_selector
from sklearn.preprocessing import FunctionTransformer, StandardScaler, OneHotEncoder
from sklearn.impute import SimpleImputer
import numpy as np

# Definir la función para calcular el ratio
def column_ratio(X):
    epsilon = 1e-8
    return X[:, [0]] / (X[:, [1]] + epsilon)

# Definir la función para nombrar la nueva columna de ratio
def ratio_name(function_transformer, feature_names_in):
    return ["ratio"]

# Crear el pipeline para calcular el ratio
def ratio_pipeline():
    return make_pipeline(
        SimpleImputer(strategy="median"),
        FunctionTransformer(column_ratio, feature_names_out=ratio_name),
        StandardScaler()
    )

# Crear el pipeline de logaritmo
log_pipeline = make_pipeline(
    SimpleImputer(strategy="median"),
    FunctionTransformer(np.log1p, feature_names_out="one-to-one"),
    StandardScaler()
)

# Crear el pipeline de preprocesamiento
preprocessing = ColumnTransformer([
    # Si el ratio original requería 2 columnas, replantea el cálculo o elimina este transformador
    # ("ratio_admision_hospitalaria_urgencias", ratio_pipeline(), ["numero_pacientes_admision_urgencias"]),
    # ("ratio_admision_hospitalaria_continua", ratio_pipeline(), ["numero_pacientes_admision_continua"]),
    ("ratio_egresos_hospitalarios_terapia", ratio_pipeline(), ["egresos_hospitalarios", "pacientes_terapia_hospital"]),
    ("ratio_defunciones_hospitalarias_urgencias", ratio_pipeline(), ["defunciones_hospitalarias", "defunciones_urgencias"]),
    ("log", log_pipeline, ["numero_pacientes_admision_urgencias", "numero_pacientes_admision_continua",
                           "egresos_hospitalarios", "pacientes_terapia_hospital",
                           "defunciones_hospitalarias", "defunciones_urgencias"]),
    ("cat", OneHotEncoder(), make_column_selector(dtype_include=object)),
], remainder=StandardScaler())

"""# Paso VIII / VIII
Predecir el número de pacientes que llegan a hospitalización a partir de admisión y terapia intensiva mediante regresión lineal.


"""

df_model = pd.read_csv(file_path)

# Renombrar las columnas (igual que hicimos anteriormente)
df_model.rename(columns={
    'año': 'anio',
    'mes': 'mes',
    'Numero de pacientes que ingresan a Admision Hospitalaria': 'numero_pacientes_admision_hospitalaria',
    'Numero de personas con ingreso de admision contínua a Hospital': 'numero_pacientes_admision_continua',
    'Numero de personas con ingreso de admision urgencias  a terapia': 'numero_pacientes_admision_urgencias',
    'Numero de pacientes en alta  de admision ': 'numero_pacientes_alta_admision',
    'Defunciones en Terapias': 'defunciones_terapia',
    'Pacientes de terapia a Hospital': 'pacientes_terapia_hospital',
    'Defunciones en Urgencias ': 'defunciones_urgencias',
    'Egresos Hospitalarios': 'egresos_hospitalarios',
    'Defunciones Hospitalarias': 'defunciones_hospitalarias',
    'Intervenciones quirúrgicas': 'intervenciones_quirogicas',
    'uso de tiempo quirurgico fin de semana en horas': 'uso_tiempo_quirogico_fin_semana_horas',
    'uso de tiempo quirurgico dias habiles en horas': 'uso_tiempo_quirogico_dias_habiles_horas'
}, inplace=True)

# Crear el pipeline de regresión lineal con preprocesamiento (usando el pipeline definido previamente)
from sklearn.linear_model import LinearRegression
from sklearn.pipeline import make_pipeline
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score

lin_reg = make_pipeline(
    preprocessing,
    LinearRegression()
)

# Ajustar el modelo:
# Se elimina la columna 'numero_pacientes_admision_hospitalaria' del dataset (ya que es la variable objetivo)
lin_reg.fit(df_model.drop("numero_pacientes_admision_hospitalaria", axis=1),
            df_model["numero_pacientes_admision_hospitalaria"])




# Preparar las features (X) y la variable objetivo (y)
X = df_model.drop("numero_pacientes_admision_hospitalaria", axis=1)
y = df_model["numero_pacientes_admision_hospitalaria"]

# Dividir los datos en entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)

# Ajustar el pipeline de regresión lineal con preprocesamiento en el conjunto de entrenamiento
lin_reg.fit(X_train, y_train)

# Realizar predicciones en el conjunto de prueba
y_pred = lin_reg.predict(X_test)

# Evaluar el desempeño del modelo
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print("Mean Squared Error:", mse)
print("R^2 Score:", r2)

